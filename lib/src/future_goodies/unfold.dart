part of future_goodies;

typedef List UnfoldUnspool(seed);
typedef bool UnfoldStopCondition(value);
typedef dynamic UnfoldProcess(value);

/**
 * Unbound list iteration
 *
 * The methods [sequence] and [pipeline] are great ways to process asynchronous
 * arrays of futures and tasks. Sometimes, however, you may not know the array
 * in advance, or may not need or want to process all the items in the array.
 *
 * For example, here are a few situations where you may not know the bounds:
 *
 * 1. You need to process a queue to which items are still being added as you process it
 * 2. You need to execute a task repeatedly until a particular condition becomes true
 * 3. You need to selectively process items in an array, rather than all items
 *
 * In these cases, you can use when/unfold to iteratively (and asynchronously)
 * process items until a particular condition, which you supply, is true.
 *
 *     Future future = unfold(unspool, stopCondition, handler, seed);
 *
 * Where:
 * * [unspool] - function that, given a seed, returns a [valueToSendToHandler, newSeed]
 * pair. May return a list, list of futures, future for an list, or future for an list of futures.
 * * [stopCondition] - function that should return truthy when the unfold should stop
 * * [handler] - function that receives the valueToSendToHandler of the current
 * iteration. This function can process valueToSendToHandler in whatever way you need.
 * It may return a [Future] to delay the next iteration of the [unfold].
 *
 * Send values produced by [unspool] iteratively to [handler] until a condition is
 * true. The [unspool] function acts like a generator, taking a [seed] and producing
 * a pair of [value, newSeed] (or a [Future] pair, see above). The value will be
 * passed to [handler], which can do any necessary on or with value, and may return
 * a future. The newSeed will be passed as the [seed] to the next iteration of [unspool].
 *
 * ## Examples
 *
 * This example generates random numbers at random intervals for 10 seconds.
 *
 * The condition could easily be modified (to return false;) to generate random numbers
 * forever. Interestingly, this would not overflow the call stack, and would not starve
 * application code since it is asynchronous.
 *
 *     Random random = new Random();
 *
 *     // set end time for 10 seconds from now
 *     DateTime end = new DateTime.now().add(new Duration(seconds: 10));
 *
 *     // Generate random numbers at random intervals!
 *     // Note that we could generate these forever, and never
 *     // blow the call stack, nor would we starve the application
 *     Function unspool = (seed) {
 *       // seed is passed in, although for this example, we don't need it
 *
 *       // Return a random number as the value, and the time it was generated
 *       // as the new seed
 *       var next = [random.nextInt(100), new DateTime.now()];
 *
 *       // Introduce a delay, just for fun, to show that we can return a promise
 *       return new Future.delayed(new Duration(milliseconds: random.nextInt(1000)), () => next);
 *     };
 *
 *     // Stop after 10 seconds
 *     Function condition = (DateTime time) {
 *       return time.isAfter(end);
 *     };
 *
 *     Function log = (value) {
 *       print(value);
 *     };
 *
 *     DateTime start = new DateTime.now();
 *
 *     unfold(unspool, condition, log, start).then((_) {
 *       print('Ran for ' + new DateTime.now().difference(start).inMicroseconds.toString() + 'ms');
 *     });
 *
 * This method idea and a lot of documentation text was were extracted from the great
 * When library: https://github.com/cujojs/when/blob/master/docs/api.md#unbounded-lists
 */
Future unfold(UnfoldUnspool unspool, UnfoldStopCondition stopCondition, UnfoldProcess handler, seed) {
  return _Unfold.run(unspool, stopCondition, handler, seed);
}

/**
 * Unfold resolving into a list
 *
 *     unfoldList(unspool, stopCondition, seed);
 *
 * Where:
 *
 * * [unspool] - function that, given a seed, returns a [valueToAddToList, newSeed] pair.
 *   May return an array, array of futures, futures for an array, or future for an array of futures.
 * * [stopCondition] - function that should return truthy when the unfold should stop
 * * [seed] - intial value provided to the first [unspool] invocation. May be a [Future].
 *
 * Generate a list of items from a [seed] by executing the [unspool] function while [stopCondition]
 * returns true. The result [Future] will fulfill with a [List] containing all each valueToAddToList
 * that is generated by [unspool].
 *
 *     Function stopCondition = (int i) => i == 3;
 *     Function unspool = (int x) => [x, x + 1];
 *
 *     unfoldList(unspool, stopCondition, 0).then((List<int> values) {
 *       print(values); // [0, 1, 2]
 *     });
 */
Future unfoldList(UnfoldUnspool unspool, UnfoldStopCondition stopCondition, seed) {
  List values = [];

  Function process = (value) {
    values.add(value);
  };

  return _Unfold.run(unspool, stopCondition, process, seed).then((_) => values);
}

class _Unfold {
  final UnfoldUnspool unspool;
  final UnfoldStopCondition stopCondition;
  final UnfoldProcess handler;
  dynamic seed;

  static Future run(UnfoldUnspool unspool, UnfoldStopCondition stopCondition, UnfoldProcess handler, seed) {
    return new _Unfold(unspool, stopCondition, handler, seed).processNext();
  }

  _Unfold(this.unspool, this.stopCondition, this.handler, this.seed);

  Future processNext() => new Future.value(seed).then(_runConditional);

  dynamic _runConditional(seedValue) {
    seed = seedValue;

    if (!stopCondition(seed))
      return _runUnspool();

    return null;
  }

  Future _runUnspool() => new Future.value(unspool(seed)).then(_runUnspoolValue);

  _runUnspoolValue(List nextAndSeed) {
    var current = nextAndSeed[0];
    seed = nextAndSeed[1];

    return new Future.value(current).then(_runProcess);
  }

  Future _runProcess(current) {
    return new Future.value(handler(current)).then((_) => processNext());
  }
}