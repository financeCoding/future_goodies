{"name":"Future goodies","tagline":"Future goodies for Dart","body":"Dart Future Goodies\r\n==============\r\n\r\n[![Build Status](https://drone.io/github.com/wilkerlucio/future_goodies/status.png)](https://drone.io/github.com/wilkerlucio/future_goodies/latest)\r\n\r\nFuture goodies for Dart.\r\n\r\nInstall\r\n-------\r\n\r\nJust add to your `pubspec.yaml`:\r\n\r\n```yaml\r\ndependencies:\r\n  future_goodies: any\r\n```\r\n\r\nUsage\r\n-----\r\n\r\nFuture goodies provides some helper functions to deal with Future management. Here we going to document each function.\r\n\r\n### allCompleted\r\n\r\nGiven a list of futures, return all that completed successfully\r\nafter all of then responded\r\n\r\n```dart\r\nallCompleted([\r\n new Future.value(1),\r\n new Future.error('err'),\r\n new Future.value(2)]).then((List results) {\r\n   print(results); // [1, 2]\r\n });\r\n```\r\n\r\nThis function is the inverse of [allRejected].\r\n\r\n### allRejected\r\n\r\nGiven a list of futures, return all that got error\r\n\r\n```dart\r\nallRejected([\r\n new Future.value(1),\r\n new Future.error('err'),\r\n new Future.value(2)]).then((List results) {\r\n   print(results); // ['err']\r\n });\r\n```\r\n\r\nThis function is the inverse of [allCompleted].\r\n\r\n### sequence\r\n\r\nThis function iteraters over a collection by calling the `iterator`, this `iterator` can either return a value, or a `Future`, if a `Future` is returned, the iteration will wait until it completes before running the next iteration. This function returns a `Future`, that will resolve as a `List` containing the result values (all resolved) of the iteration. If any iteration fails (sync or async) the `sequence` will stop and the `Future` returned by it will fail with the error.\r\n\r\n```dart\r\nimport 'package:future_goodies/future_goodies.dart';\r\nimport 'dart:async';\r\n\r\nFuture delayed(value) {\r\n  return new Future.delayed(new Duration(milliseconds: 20), () => value));\r\n}\r\n\r\nvoid main() {\r\n  Future<List<int>> result = sequence([1, 2, 3, 4], (n) => delayed(n * 2));\r\n\r\n  result.then((List<int> values) {\r\n    print(values); // [2, 4, 6, 8]\r\n  });\r\n}\r\n```\r\n\r\n### pipeline\r\n\r\nReduces a collection to a single value by iteratively combining each\r\nelement of the collection with an existing value using the provided\r\nfunction. The iterator must return a Future, and the iterator\r\nwill wait for it before moving on.\r\n\r\nIf any iteration fails the result Future will fail with same error.\r\n\r\n```dart\r\nFuture simpleDelay(value) => new Future.delayed(new Duration(milliseconds: 10));\r\n\r\npipeline('', ['a', 'b', 'c'], (String acc, String v) => simpleDelay(acc + v)).then((String result) {\r\n  print(result); // 'abc'\r\n});\r\n```\r\n\r\n### FutureWorker\r\n\r\nManagers a Future worker poll\r\n\r\nThe purpouse of this class is to help when you need to impose some limit\r\nfor Future calls. You just need to initialize with the limit number of\r\nworkers, then you call push passing a function that returns a Future\r\nand with that the worker will manage to call this function when the poll\r\nhas space:\r\n\r\n```dart\r\nclass SimpleJob {\r\n  bool started = false;\r\n  Completer completer = new Completer();\r\n\r\n  Future run() {\r\n    started = true;\r\n\r\n    return completer.future;\r\n  }\r\n}\r\n\r\nFutureWorker worker = new FutureWorker(2);\r\n\r\nSimpleJob job1 = new SimpleJob();\r\nSimpleJob job2 = new SimpleJob();\r\nSimpleJob job3 = new SimpleJob();\r\n\r\nFuture future1 = worker.push(job1.run); // will call right way since the poll is free\r\nFuture future2 = worker.push(job2.run); // same as before, still have space\r\nFuture future3 = worker.push(job3.run); // will be queued and hold\r\n\r\njob1.started; // true\r\njob2.started; // true\r\njob3.started; // false\r\n\r\njob1.completer.complete(null);\r\n\r\nnew Future.microtask(() {\r\n  job3.started; // true\r\n});\r\n\r\nfuture3.then((value) {\r\n  value; // done, after the job3 completes\r\n});\r\n\r\njob3.completer.complete('done');\r\n```\r\n\r\nYou probably going to use it when you wanna limit calls for a server and stuff\r\nlike that, so since adding a timeout is a common practice (to avoid the poll to\r\nnever get free slots) you can send a duration to timeout when constructing the\r\nworker.\r\n\r\n```dart\r\nFutureWorker worker = new FutureWorker(2, timeout: new Duration(seconds: 15));\r\n```\r\n\r\n### settle\r\n\r\nMakes a list of futures always completes, returning the state of\r\nthe completion.\r\n\r\n```dart\r\nsettle([new Future.value('hello'), new Future.error('err')]).then((List<SettleResult> results) {\r\n  results[0]; // <SettleResult status:#completed result:hello>\r\n  results[1]; // <SettleResult status:#rejected error:err>\r\n});\r\n```\r\n\r\nIf you wanna do it for a single future, check [SettleResult.settle]\r\n\r\n### SettleResult.settle\r\n\r\nWraps a future to always completes with a SettleResult\r\n\r\nThis function will return a [Future], this future will\r\nbe an instance of [SettleResult].\r\n\r\nGiven the original future has completed with success,\r\nthe [SettleResult] will have the [status] value of\r\n[COMPLETED] and the [result] will have the completion value.\r\n\r\nGiven the original future fails, the [SettleResult] will\r\nhave the [status] as [REJECTED] and the `error` will contain\r\nthe thrown error.\r\n\r\n```dart\r\nSettleResult.settle(new Future.value('ok')).then((SettleResult res) {\r\n res.status; // SettleResult.COMPLETED\r\n res.result; // 'ok'\r\n res.error; // null\r\n});\r\n\r\nSettleResult.settle(new Future.error('err')).then((SettleResult res) {\r\n  res.status; // SettleResult.REJECTED\r\n  res.result; // null\r\n  res.error; // 'err'\r\n});\r\n```\r\n\r\n### unfold\r\n\r\nThe methods [sequence] and [pipeline] are great ways to process asynchronous\r\narrays of futures and tasks. Sometimes, however, you may not know the array\r\nin advance, or may not need or want to process all the items in the array.\r\n\r\nFor example, here are a few situations where you may not know the bounds:\r\n\r\n1. You need to process a queue to which items are still being added as you process it\r\n2. You need to execute a task repeatedly until a particular condition becomes true\r\n3. You need to selectively process items in an array, rather than all items\r\n\r\nIn these cases, you can use when/unfold to iteratively (and asynchronously)\r\nprocess items until a particular condition, which you supply, is true.\r\n\r\n    Future future = unfold(unspool, stopCondition, handler, seed);\r\n\r\nWhere:\r\n* [unspool] - function that, given a seed, returns a [valueToSendToHandler, newSeed]\r\npair. May return a list, list of futures, future for an list, or future for an list of futures.\r\n* [stopCondition] - function that should return truthy when the unfold should stop\r\n* [handler] - function that receives the valueToSendToHandler of the current\r\niteration. This function can process valueToSendToHandler in whatever way you need.\r\nIt may return a [Future] to delay the next iteration of the [unfold].\r\n\r\nSend values produced by [unspool] iteratively to [handler] until a condition is\r\ntrue. The [unspool] function acts like a generator, taking a [seed] and producing\r\na pair of [value, newSeed] (or a [Future] pair, see above). The value will be\r\npassed to [handler], which can do any necessary on or with value, and may return\r\na future. The newSeed will be passed as the [seed] to the next iteration of [unspool].\r\n\r\n## Examples\r\n\r\nThis example generates random numbers at random intervals for 10 seconds.\r\n\r\nThe condition could easily be modified (to return false;) to generate random numbers\r\nforever. Interestingly, this would not overflow the call stack, and would not starve\r\napplication code since it is asynchronous.\r\n\r\n```dart\r\nRandom random = new Random();\r\n\r\n// set end time for 10 seconds from now\r\nDateTime end = new DateTime.now().add(new Duration(seconds: 10));\r\n\r\n// Generate random numbers at random intervals!\r\n// Note that we could generate these forever, and never\r\n// blow the call stack, nor would we starve the application\r\nFunction unspool = (seed) {\r\n  // seed is passed in, although for this example, we don't need it\r\n\r\n  // Return a random number as the value, and the time it was generated\r\n  // as the new seed\r\n  var next = [random.nextInt(100), new DateTime.now()];\r\n\r\n  // Introduce a delay, just for fun, to show that we can return a future\r\n  return new Future.delayed(new Duration(milliseconds: random.nextInt(1000)), () => next);\r\n};\r\n\r\n// Stop after 10 seconds\r\nFunction condition = (DateTime time) {\r\n  return time.isAfter(end);\r\n};\r\n\r\nFunction log = (value) {\r\n  print(value);\r\n};\r\n\r\nDateTime start = new DateTime.now();\r\n\r\nunfold(unspool, condition, log, start).then((_) {\r\n  print('Ran for ' + new DateTime.now().difference(start).inMicroseconds.toString() + 'ms');\r\n});\r\n```\r\n\r\n### unfoldList\r\n\r\nUnfold resolving into a list\r\n\r\n    unfoldList(unspool, stopCondition, seed);\r\n\r\nWhere:\r\n\r\n* [unspool] - function that, given a seed, returns a [valueToAddToList, newSeed] pair.\r\n  May return an array, array of futures, futures for an array, or future for an array of futures.\r\n* [stopCondition] - function that should return truthy when the unfold should stop\r\n* [seed] - intial value provided to the first [unspool] invocation. May be a [Future].\r\n\r\nGenerate a list of items from a [seed] by executing the [unspool] function while [stopCondition]\r\nreturns true. The result [Future] will fulfill with a [List] containing all each valueToAddToList\r\nthat is generated by [unspool].\r\n\r\n```dart\r\nFunction stopCondition = (int i) => i == 3;\r\nFunction unspool = (int x) => [x, x + 1];\r\n\r\nunfoldList(unspool, stopCondition, 0).then((List<int> values) {\r\n  print(values); // [0, 1, 2]\r\n});\r\n```\r\n\r\nThe methods [unfold] and [unfoldList] ideas and a lot of documentation text was were extracted from the great\r\nWhen library: https://github.com/cujojs/when/blob/master/docs/api.md#unbounded-lists\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}